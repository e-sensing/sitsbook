# Regular EO data cubes

### Configurations to run the chapter{-}

```{r}
#| echo: false
reticulate::use_python("/Users/gilbertocamara/.pyenv/versions/pysits/bin/python")
```

:::{.panel-tabset}
## R
```{r}
#| echo: true
#| eval: true
#| output: false
# load package "tibble"
library(tibble)
# load packages "sits" and "sitsdata"
library(sits)
library(sitsdata)
# set tempdir if it does not exist 
tempdir_r <- "~/sitsbook/tempdir/R/dc_regularize"
dir.create(tempdir_r, showWarnings = FALSE)
```
## Python
```{python}
#| echo: true
#| eval: false
#| output: false
from pysits import *
import pandas as pd
pd.set_option("display.max_columns", 100)
pd.set_option("display.max_rows", 4)
# set bookdir if it does not exist 
from pathlib import Path
home = str(Path.home())
tempdir_py = home + "/sitsbook/tempdir/Python/dc_regularize"
Path(tempdir_py).mkdir(parents=True, exist_ok=True)
```
:::

## The need for regular EO data cubes

ARD collections available in AWS, MPC, USGS, and DEAFRICA are not regular in space and time. Bands may have different resolutions, images may not cover the entire tile, and time intervals are irregular. Clouds and sensor artefacts introduce “holes” in the data, which need to be filled to obtain a consistent time series. Most ML/DL libraries expect tensors of identical shape (n_samples × n_features × time). If time steps differ or values are missing, batch training breaks and the model learns spurious correlations. Regular cubes guarantee fixed-length feature vectors & GPU-friendly batches. Regularisation turns heterogeneous image archives into a clean data structure that machine learning models can ingest directly. 

Data from ARD collections can be converted to regular data cubes by calling `sits_regularize()`, which uses the  `gdalcubes` package [@Appel2019]. The `sits_regularize()` function has two components:

1. Spatial harmonisation: re-project and resample everything onto the same tiling system and same spatial resolution. For examples, when Sentinel-1 and Sentinel-2 images are merged in `sits`, they are projected to tiles of the MGRS grid. 

2. Temporal harmonisation: creates equispaced intervals (e.g., 16-day, monthly or seasonal composites) and fills gaps due to cloud cover and sensor errors. In `sits`, all images inside a chosen interval are combined by stacking. Images are ordered by decreasing percentage of cloud cover. The least-cloud filled image is taken as reference, and the other images are used to try to fill ist gaps. Pixels with persistent cloud-cover are marked as `NA` and are estimated during computation by temporal interpolation. 



## Regularizing Sentinel-2 images{-}

In the following example, the user has created a non-regular data cube from the Sentinel-2 collection available in Microsoft's Planetary Computer (MPC) for tiles `20LKP` and `20LLP` in the state of Rondonia, Brazil. We first retrieve a non-regular ARD collection using `sits_cube()`.

:::{.panel-tabset}
## R
```{r}
#| eval: false
# Retrieving a non-regular ARD collection from AWS
s2_cube_rondonia <- sits_cube(
    source = "AWS",
    collection = "SENTINEL-2-L2A",
    tiles = c("20LLP", "20LKP"),
    bands = c("B02", "B8A", "B11", "CLOUD"),
    start_date = as.Date("2018-06-30"),
    end_date = as.Date("2018-08-31")
)
# Show the different timelines of the cube tiles
sits_timeline(s2_cube_rondonia)
```
## Python
```{python}
#| eval: false
# Retrieving a non-regular ARD collection from AWS
s2_cube_rondonia =  sits_cube(
    source = "AWS",
    collection = "SENTINEL-2-L2A",
    tiles = ["20LLP", "20LKP"],
    bands = ["B02", "B8A", "B11", "CLOUD"],
    start_date = "2018-06-30",
    end_date = "2018-08-31"
)
# Show the different timelines of the cube tiles
sits_timeline(s2_cube_rondonia)
```
:::

```{r}
#| echo: false
s2_cube_rondonia_timeline <- readRDS("./etc/s2_cube_rondonia_timeline.rds")
s2_cube_rondonia_timeline
```

:::{.panel-tabset}
## R
```{r}
#| eval: false
# plot the least cloudy image of the cube
s2_cube_rondonia |>  
    dplyr::filter(tile == "20LLP") |>  
    plot()
```
## Python
```{python}
#| eval: false
plot(s2_cube_rondonia)
```
:::

```{r}
#| echo: false
#| label: fig-s220llp-dc
#| out-width: 80%
#| fig-cap: |
#|      Instance of non-regularized Sentinel-2 image covering only part of tile tile 20LLP.
#| fig-align: center
knitr::include_graphics("./images/dc_regularize_s2_20llp_non_reg.png") 
```

Because of the different acquisition orbits of the Sentinel-2A and Sentinel-2B satellites, the two tiles also have different timelines. Tile `20LKP` has 12 instances, while tile `20LLP` has 24 instances for the chosen period. The function  `sits_regularize()` builds a data cube with a regular timeline and a best estimate of a valid pixel for each interval. The `period` parameter sets the time interval between two images. Values of `period` use the ISO8601 time period specification, which defines time intervals as `P[n]Y[n]M[n]D`, where "Y" stands for years, "M" for months, and "D" for days. Thus, `P1M` stands for a one-month period, `P15D` for a fifteen-day period. When joining different images to get the best image for a period, `sits_regularize()` uses an aggregation method that organizes the images for the chosen interval in order of increasing cloud cover and then selects the first cloud-free pixel. In the example, we use a spatial resolution of 40-meter for the regular cube to speed up processing; in actual case, we suggest using a 10-meter spatial resolution for the cube.

Before regularizing the cube, we suggest copying the ARD data to a local directory to speed up processing. The original data will be temporally stored locally. In this way, the actual work of producing a regular data cube will be split into two parts: (a) downloading data from ARD collections; (b) building a data cube from local files. After the regular data cube has been built, the ARD imagens can be deleted. Depending on the speed of your connection, the `sits_cube_copy()` may take some time.



:::{.panel-tabset}
## R
```{r}
#| eval: false
# set output dir for ARD data if it does not exist 
tempdir_r_s2 <- "~/sitsbook/tempdir/R/dc_regularize/s2"
dir.create(tempdir_r_s2, showWarnings = FALSE)

s2_cube_local <- sits_cube_copy(
    cube = s2_cube_rondonia,
    output_dir = tempdir_r_s2
)
# set output dir fir regular cube if it does not exist 
tempdir_r_s2_reg <- "~/sitsbook/tempdir/R/dc_regularize/s2_reg"
dir.create(tempdir_r_s2, showWarnings = FALSE)

# Regularize the cube to 16-day intervals
reg_cube_rondonia <- sits_regularize(
          cube       = s2_cube_rondonia,
          output_dir = tempdir_r_s2_reg,
          res        = 40,
          period     = "P16D",
          multicores = 6)

# Plot tile 20LLP of the regularized cube with the least cloud cover
# The pixels of the regular data cube cover the full MGRS tile
plot(reg_cube_rondonia, tile = "20LLP")
```
## Python
```{python}
#| eval: false
# To be completed
```
:::

```{r}
#| echo: false
#| label: fig-s2reg-dc
#| out-width: 80%
#| fig-cap: Regularized image for tile Sentinel-2 tile 20LLP.
knitr::include_graphics("./images/dc_regularize_20llp_reg.png")
```


## Regularizing Sentinel-1 images{-}

Because of their acquisition mode, SAR images are usually stored following their geometry of acquisition, which is inclined with respect to the Earth. This is the case of GRD and RTC collections available in Microsoft Planetary Computer (MPC). To allow easier use of Sentinel-1 data and to merge them with Sentinel-2 images, regularization in sits reprojects SAR data to the MGRS grid, as shown in the following example. The example uses the "SENTINEL-1-RTC" collection from MPC. 

```{r}
#| eval: false
# create an RTC cube from MPC collection for a region in Mato Grosso, Brazil.
cube_s1_rtc <-  sits_cube(
    source = "MPC",
    collection = "SENTINEL-1-RTC",
    bands = c("VV", "VH"),
    orbit = "descending",
    tiles = c("22LBL"),
    start_date = "2021-06-01",
    end_date = "2021-10-01"
)
plot(cube_s1_rtc, band = "VH", palette = "Greys", scale = 0.7)
```

```{r}
#| echo: false
#| label: fig-s1orig-dc
#| out-width: 80%
#| fig-cap: |
#|   "Original Sentinel-1 image covering tile 22LBL.
#| fig-align: center
knitr::include_graphics("./images/cube_s1_rtc_tile_22LBL_vh.png") 
```

After retrieving a non-regular ARD collection from the data available in MPC, we use `sits_regularize()` to produce a SAR data cube that matches MGRS tile "22LBL". For plotting the SAR image, we select a multidate plot for the "VH" band, where the first date will be displayed in red, the second in green and the third in blue, so as to show an RGB map where changes are visually enhanced.

```{r}
#| eval: false
# define the output directory
# set outout dir if it does not exist 
tempdir_r_sar <- "~/sitsbook/tempdir/R/dc_regularize/sar"
dir.create(tempdir_r_sar, showWarnings = FALSE)
# create a regular RTC cube from MPC collection for a tile 22LBL.
cube_s1_reg <- sits_regularize(
    cube = cube_s1_rtc,
    period = "P16D",
    res = 40,
    tiles = c("22LBL"),
    memsize = 12,
    multicores = 6,
    output_dir = tempdir_r_sar
)
plot(cube_s1_reg, band = "VH", palette = "Greys", scale = 0.7, 
     dates = c("2021-06-06", "2021-07-24", "2021-09-26"))
```

```{r}
#| echo: false
#| label: fig-s1reg-dc
#| out-width: 80%
#| fig-cap: |
#|   Regularized Sentinel-1 image covering tile 22LBL.
#| fig-align: center
knitr::include_graphics("./images/dc_s1reg_three_dates.png")
```

## Summary 

In this chapter, we learned how to produced regular EO cubes from non-regular subset of ARD collections. Regularization is a key operation when working with time series, since it allow the use of machine learning models on time series. In the next chapter, we will discuss how to merge sensors from different data sources and, when necessary, to combine these data sets with regularization operations. 

## References{-}