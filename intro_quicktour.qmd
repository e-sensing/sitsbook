# A quick tour of SITS

<a href="https://www.kaggle.com/esensing/introduction-to-sits" target="_blank"><img src="https://kaggle.com/static/images/open-in-kaggle.svg"/></a>

## Creating a data cube

There are two kinds of data cubes in `sits`: (a) irregular data cubes generated by selecting image collections on cloud providers such as AWS and Planetary Computer; (b) regular data cubes with images fully covering a chosen area, where each image has the same spectral bands and spatial resolution, and images follow a set of adjacent and regular time intervals. Machine learning applications need regular data cubes. Please refer to Chapter [Earth observation data cubes](https://e-sensing.github.io/sitsbook/earth-observation-data-cubes.html) for further details.

The first step in using `sits` is configuring the environment to for running `R` and `Python` together. 
::: {.panel-tabset}
## R 
```{r}
#| echo: true
#| eval: true
#| output: false
# load package "tibble"
library(tibble)
# load packages "sits" and "sitsdata"
library(sits)
library(sitsdata)
# set tempdir if it does not exist 
tempdir_r <- "~/sitsbook/tempdir/R/intro_quicktour"
dir.create(tempdir_r, showWarnings = FALSE)
```
## Python
```{python}
#| output: false
from pysits import *
import pandas as pd
pd.set_option("display.max_columns", 100)
pd.set_option("display.max_rows", 4)
# set data directory
sitsdata_dir = "/Library/Frameworks/R.framework/Versions/4.4-x86_64/Resources/library/sitsdata/"
# set bookdir if it does not exist 
from pathlib import Path
tempdir_py = "~/sitsbook/tempdir/Python/intro_quicktour"
Path(tempdir_py).mkdir(parents=True, exist_ok=True)
```
:::
Please also provide the location of the python interpreter that supports the integration of `sits` in `Python`. 
```{r}
reticulate::use_python("/Users/gilbertocamara/.pyenv/versions/pysits/bin/python")
```


The first steps in using `sits` are: (a) select an analysis-ready data image collection available in a cloud provider or stored locally using `sits_cube()`; (b) if the collection is not regular, use `sits_regularize()` to build a regular data cube.

This example builds a data cube from local images already organized as a regular data cube. The data cube is composed of MODIS MOD13Q1 images for the region close to the city of Sinop in Mato Grosso, Brazil. This region is one of the world's largest producers of soybeans. All images have indexes NDVI and EVI covering a one-year period from 2013-09-14 to 2014-08-29 (we use "year-month-day" for dates). There are 23 time instances, each covering a 16-day period. This data is available in the package `sitsdata`. For more details on building data cubes from local files, see Chapter "Data cubes from local files". 

::: {.panel-tabset}
## R
```{r}
#| label: fig-intro-ndvi-r
#| out-width: 100%
#| out-height: 100%
#| fig-cap: |
#|   False color MODIS image for NDVI band in 2013-09-14.
#| fig-align: center
# Create a data cube using local files
sinop_cube <- sits_cube(
  source = "BDC", 
  collection  = "MOD13Q1-6.1",
  bands = c("NDVI", "EVI"),
  data_dir = system.file("extdata/sinop", package = "sitsdata"),  
  parse_info = c("satellite", "sensor", "tile", "band", "date")
)
# Plot the NDVI for the first date (2013-09-14)
plot(sinop_cube, 
     band = "NDVI", 
     dates = "2013-09-14",
     palette = "RdYlGn")
```
## Python
```{python}
#| eval: true
#| label: fig-intro-ndvi-py
#| out-width: 100%
#| out-height: 100%
#| fig-cap: |
#|   False color MODIS image for NDVI band in 2013-09-14.
#| fig-align: center
# Create a data cube using local files
sinop_cube = sits_cube(
  source = "BDC", 
  collection  = "MOD13Q1-6.1",
  bands = ["NDVI", "EVI"],
  data_dir = sitsdata_dir + "extdata/sinop",  
  parse_info = ["satellite", "sensor", "tile", "band", "date"]
)
# Plot the NDVI for the first date (2013-09-14)
plot(sinop_cube, 
     band = "NDVI", 
     dates = "2013-09-14",
     palette = "RdYlGn")
```
:::

The aim of the `parse_info` parameter is to extract `tile`, `band`, and `date` information from the file name. Given the large variation in image file names generated by different produces, it includes designators such as `X1` and `X2`; these are place holders for parts of the file name that is not relevant to `sits_cube()`.

The R object returned by `sits_cube()` contains the metadata describing the contents of the data cube. It includes data source and collection, satellite, sensor, tile in the collection, bounding box, projection, and list of files. Each file refers to one band of an image at one of the temporal instances of the cube.

::: {.panel-tabset}
## R
```{r}
# Show the description of the data cube
sinop_cube
```
## Python
```{python}
# Show the description of the data cube
sinop_cube
```
:::

The list of image files which make up the data cube is stored as a data frame in the column `file_info`. For each file, `sits` stores information about spectral band, reference date, size, spatial resolution, coordinate reference system, bounding box, path to file location and cloud cover information (when available).

::: {.panel-tabset}
## R
```{r}
# Show information on the images files which are part of a data cube
sinop_cube$file_info[[1]]
```
## Python
```{python}
# Show information on the images files which are part of a data cube
sinop_cube["file_info"][0]
```
:::

A key attribute of a data cube is its timeline, as shown below. The command `sits_timeline()` lists the temporal references associated to `sits` objects, including samples, data cubes and models.

::: {.panel-tabset}
## R
```{r}
# Show the R object that describes the data cube
sits_timeline(sinop_cube)
```
## Python
```{python}
# Show the R object that describes the data cube
sits_timeline(sinop_cube)
```
:::
The timeline of the `sinop_cube` data cube has 23 intervals with a temporal difference of 16 days. The chosen dates capture the agricultural calendar in Mato Grosso, Brazil. The agricultural year starts in September-October with the sowing of the summer crop (usually soybeans) which is harvested in February-March. Then the winter crop (mostly Corn, Cotton or Millet) is planted in March and harvested in June-July. For LULC classification, the training samples and the date cube should share a timeline with the same number of intervals and similar start and end dates.

## The time series tibble

To handle time series information, `sits` uses a `tibble`. Tibbles are extensions of the `data.frame` tabular data structures provided by the `tidyverse` set of packages. The example below shows a tibble with 1,837 time series obtained from MODIS MOD13Q1 images. Each series has two indexes (NDVI and EVI). This dataset is available in package `sitsdata`.

The time series tibble contains data and metadata. The first six columns contain the metadata: spatial and temporal information, the label assigned to the sample, and the data cube from where the data has been extracted. The `time_series` column contains the time series data for each spatiotemporal location. This data is also organized as a tibble, with a column with the dates and the other columns with the values for each spectral band.

::: {.panel-tabset}
## R
```{r}
# Load the MODIS samples for Mato Grosso from the "sitsdata" package
library(tibble)
library(sitsdata)
samples_dir <- system.file("data", package = "sitsdata")
samples_matogrosso_modis <- readRDS(file.path(samples_dir, "samples_matogrosso_modis.rds"))
samples_matogrosso_modis
```
## Python 
```{python}
# Load the MODIS samples for Mato Grosso from the "sitsdata" package
samples_file = sitsdata_dir + "/data/samples_matogrosso_modis.rds"
samples_matogrosso_modis = read_sits_rds(samples_file)
samples_matogrosso_modis
```
:::
The timeline for all time series associated with the samples follows the same agricultural calendar, starting in September 14th and ending in August 28th. All samples contain 23 values, corresponding to the same temporal interval as those of the `sinop` data cube. Notice that that although the years for the samples are different, the samples for a given year follow the same agricultural calendar.

The time series can be displayed by showing the `time_series` nested column.

::: {.panel-tabset}
## R
```{r}
# Load the time series for the first MODIS sample for Mato Grosso
samples_matogrosso_modis[1,]$time_series[[1]]
```
## Python
```{python}
# Load the time series for the first MODIS sample for Mato Grosso
samples_matogrosso_modis["time_series"][1]
```
:::

The distribution of samples per class can be obtained using the `summary()` command. The classification schema uses nine labels, four associated to crops (`Soy_Corn`, `Soy_Cotton`, `Soy_Fallow`, `Soy_Millet`), two with natural vegetation (`Cerrado`, `Forest`) and one to `Pasture`.

::: {.panel-tabset}
## R
```{r}
# Show the summary of the time series sample data
summary(samples_matogrosso_modis)
```
## Python
```{python}
#| eval: false
# Show the summary of the time series sample data
summary(samples_matogrosso_modis)
```
:::

It is helpful to plot the dispersion of the time series. In what follows, for brevity, we will filter only one label (`Forest`) and select one index (NDVI). 

::: {.panel-tabset}
## R
```{r}
#| label: fig-ts-forest-r
#| out-width: 80%
#| fig-cap: |
#|   Joint plot of all samples in band NDVI for label Forest.
#| fig-align: center
# Select all samples with label "Forest" using `dplyr::filter`
# since the label attribute is a column of the samples data.frame
samples_forest <- dplyr::filter(
    samples_matogrosso_modis, 
    label == "Forest"
) |> 
# Select the NDVI band values using sits_select
# because band values are in a nested data.frame
sits_select(
    bands = "NDVI"
) |> 
plot()
```
## Python
```{python}
#| eval: false
#| label: fig-ts-forest-py
#| out-width: 80%
#| fig-cap: |
#|   Joint plot of all samples in band NDVI for label Forest.
#| fig-align: center
# Select all samples with label "Forest" using `query` 
# since the label attribute is a column of the samples data.frame
samples_forest = samples_matogrosso_modis.query('label == "Forest"')
# Select the NDVI band values using sits_select
# because band values are in a nested data.frame
samples_forest_ndvi = sits_select(samples_forest, bands = "NDVI")
# plot the samples for label Forest and band NDVI
plot(samples_forest_ndvi)
```
:::

The above figure shows all the time series associated with label `Forest` and band NDVI (in light blue), highlighting the median (shown in dark red) and the first and third quartiles (shown in brown). The spikes are noise caused by the presence of clouds.

## Training a machine learning model

The next step is to train a machine learning (ML) model using `sits_train()`. It takes two inputs, `samples` (a time series tibble) and `ml_method` (a function that implements a machine learning algorithm). The result is a model that is used for classification. Each ML algorithm requires specific parameters that are user-controllable. For novice users, `sits` provides default parameters that produce good results. Please see Chapter [Machine learning for data cubes](https://e-sensing.github.io/sitsbook/machine-learning-for-data-cubes.html) for more details.

To build the classification model, we use a random forest model called by `sits_rfor()`. Results from the random forest model can vary between different runs, due to the stochastic nature of the algorithm, For this reason, in the code fragment below, we set the seed of R's pseudo-random number generation explicitly to ensure the same results are produced for documentation purposes.

::: {.panel-tabset}
## R
```{r}
#| label: fig-rf-intro-r
#| out-width: 80%
#| fig-cap: |
#|   Most relevant variables of trained random forest model.
#| fig-align: center
set.seed(03022024)
# Train a random forest model
rf_model <- sits_train(
    samples = samples_matogrosso_modis, 
    ml_method = sits_rfor()
)
# Plot the most important variables of the model
plot(rf_model)
```
## Python 
```{python}
#| label: fig-rf-intro-py
#| out-width: 80%
#| fig-cap: |
#|   Most relevant variables of trained random forest model.
#| fig-align: center
# Train a random forest model
rf_model = sits_train(
    samples = samples_matogrosso_modis, 
    ml_method = sits_rfor()
)
# Plot the most important variables of the model
plot(rf_model)
```
:::


## Data cube classification

After training the machine learning model, the next step is to classify the data cube using `sits_classify()`. This function produces a set of raster probability maps, one for each class. For each of these maps, the value of a pixel is proportional to the probability that it belongs to the class. This function has two mandatory parameters: `data`, the data cube or time series tibble to be classified; and `ml_model`, the trained ML model. Optional parameters include: (a) `multicores`, number of cores to be used; (b) `memsize`, RAM used in the classification; (c) `output_dir`, the directory where the classified raster files will be written. Details of the classification process are available in Chapter [Image classification in data cubes](https://e-sensing.github.io/sitsbook/rasterclassification.html).

:::{.panel-tabset}
## R
```{r}
#| label: fig-prob-intro-r
#| out-width: 90%
#| fig-cap: |
#|   Probability map for class Forest.
#| fig-align: center
# Classify the raster image
sinop_probs <- sits_classify(
    data = sinop_cube, 
    ml_model = rf_model,
    multicores = 2,
    memsize = 8,
    output_dir = tempdir_r
)
# Plot the probability cube for class Forest
plot(sinop_probs, labels = "Forest", palette = "BuGn")
```
## Python
```{python}
#| label: fig-prob-intro-py
#| out-width: 90%
#| fig-cap: |
#|   Probability map for class Forest.
#| fig-align: center
# Classify the raster image
sinop_probs = sits_classify(
    data = sinop_cube, 
    ml_model = rf_model,
    multicores = 2,
    memsize = 8,
    output_dir = tempdir_py
)
# Plot the probability cube for class Forest
plot(sinop_probs, labels = "Forest", palette = "BuGn")
```
:::

After completing the classification, we plot the probability maps for class `Forest`. Probability maps are helpful to visualize the degree of confidence the classifier assigns to the labels for each pixel. They can be used to produce uncertainty information and support active learning, as described in Chapter [Image classification in data cubes](https://e-sensing.github.io/sitsbook/rasterclassification.html).

## Spatial smoothing

When working with big Earth observation data, there is much variability in each class. As a result, some pixels will be misclassified. These errors are more likely to occur in transition areas between classes. To address these problems, `sits_smooth()` takes a probability cube as input and uses the class probabilities of each pixel's neighborhood to reduce labeling uncertainty. Plotting the smoothed probability map for class Forest shows that most outliers have been removed.

:::{.panel-tabset}
## R
```{r}
#| label: fig-bayes-intro-r
#| out-width: 90%
#| fig-cap: |
#|   Smoothed probability map for class Forest.
#| fig-align: center
# Perform spatial smoothing
sinop_bayes <- sits_smooth(
    cube = sinop_probs,
    multicores = 2,
    memsize = 8,
    output_dir = tempdir_r
)
plot(sinop_bayes, labels = "Forest", palette = "BuGn")
```
## Python
```{python}
#| label: fig-bayes-intro-py
#| out-width: 90%
#| fig-cap: |
#|   Smoothed probability map for class Forest.
#| fig-align: center
# Perform spatial smoothing
sinop_bayes = sits_smooth(
    cube = sinop_probs,
    multicores = 2,
    memsize = 8,
    output_dir = tempdir_py
)
plot(sinop_bayes, labels = "Forest", palette = "BuGn")
```
:::

## Labeling a probability data cube

After removing outliers using local smoothing, the final classification map can be obtained using `sits_label_classification()`. This function assigns each pixel to the class with the highest probability.

:::{.panel-tabset}
## R
```{r}
#| label: fig-map-intro-r
#| out-width: 100%
#| fig-cap: |
#|   Classification map for Sinop.
#| fig-align: center
# Label the probability file 
sinop_map <- sits_label_classification(
    cube = sinop_bayes, 
    output_dir = tempdir_r
)
plot(sinop_map)
```
## Python
```{python}
#| label: fig-map-intro-py
#| out-width: 100%
#| fig-cap: |
#|   Classification map for Sinop.
#| fig-align: center
# Label the probability file 
sinop_map = sits_label_classification(
    cube = sinop_bayes, 
    output_dir = tempdir_py
)
plot(sinop_map)
```
:::

The resulting classification files can be read by QGIS. Links to the associated files are available in the `sinop_map` data.frame in the nested table `file_info`.

:::{.panel-tabset}
## R
```{r}
# Show the location of the classification file
sinop_map$file_info[[1]]
```
## Python
```{python}
# Show the location of the classification file
sinop_map["file_info"][0]
```
:::