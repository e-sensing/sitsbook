<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Object-based time series image analysis | sits: Satellite Image Time Series Analysis on Earth Observation Data Cubes</title>
<meta name="author" content="Gilberto Camara">
<meta name="author" content="Rolf Simoes">
<meta name="author" content="Felipe Souza">
<meta name="author" content="Charlotte Pelletier">
<meta name="author" content="Alber Sanchez">
<meta name="author" content="Pedro R. Andrade">
<meta name="author" content="Karine Ferreira">
<meta name="author" content="Gilberto Queiroz">
<meta name="description" content="Object-Based Image Analysis (OBIA) is an approach to remote sensing image analysis that partitions an image into closed segments which are then classified and analyzed. For high-resolution images...">
<meta name="generator" content="bookdown 0.35 with bs4_book()">
<meta property="og:title" content="Object-based time series image analysis | sits: Satellite Image Time Series Analysis on Earth Observation Data Cubes">
<meta property="og:type" content="book">
<meta property="og:image" content="/images/cover_sits_book.png">
<meta property="og:description" content="Object-Based Image Analysis (OBIA) is an approach to remote sensing image analysis that partitions an image into closed segments which are then classified and analyzed. For high-resolution images...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Object-based time series image analysis | sits: Satellite Image Time Series Analysis on Earth Observation Data Cubes">
<meta name="twitter:description" content="Object-Based Image Analysis (OBIA) is an approach to remote sensing image analysis that partitions an image into closed segments which are then classified and analyzed. For high-resolution images...">
<meta name="twitter:image" content="/images/cover_sits_book.png">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><link href="libs/IBM_Plex_Serif-0.4.7/font.css" rel="stylesheet">
<link href="libs/IBM_Plex_Mono-0.4.7/font.css" rel="stylesheet">
<script src="libs/bs3compat-0.5.1/transition.js"></script><script src="libs/bs3compat-0.5.1/tabs.js"></script><script src="libs/bs3compat-0.5.1/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><script src="libs/kePrint-0.0.1/kePrint.js"></script><link href="libs/lightable-0.0.1/lightable.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><style type="text/css">
    
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  </style>
<style type="text/css">
    /* Used with Pandoc 2.11+ new --citeproc when CSL is used */
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
        }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title=""><strong>sits</strong>: Satellite Image Time Series Analysis on Earth Observation Data Cubes</a>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">Preface</a></li>
<li><a class="" href="setup.html">Setup</a></li>
<li><a class="" href="acknowledgements.html">Acknowledgements</a></li>
<li><a class="" href="introduction.html">Introduction</a></li>
<li><a class="" href="earth-observation-data-cubes.html">Earth observation data cubes</a></li>
<li><a class="" href="operations-on-data-cubes.html">Operations on data cubes</a></li>
<li><a class="" href="working-with-time-series.html">Working with time series</a></li>
<li><a class="" href="improving-the-quality-of-training-samples.html">Improving the quality of training samples</a></li>
<li><a class="" href="machine-learning-for-data-cubes.html">Machine learning for data cubes</a></li>
<li><a class="" href="image-classification-in-data-cubes.html">Image classification in data cubes</a></li>
<li><a class="" href="bayesian-smoothing-for-post-processing.html">Bayesian smoothing for post-processing</a></li>
<li><a class="" href="validation-and-accuracy-measurements.html">Validation and accuracy measurements</a></li>
<li><a class="" href="uncertainty-and-active-learning.html">Uncertainty and active learning</a></li>
<li><a class="" href="ensemble-prediction-from-multiple-models.html">Ensemble prediction from multiple models</a></li>
<li><a class="active" href="object-based-time-series-image-analysis.html">Object-based time series image analysis</a></li>
<li><a class="" href="technical-annex.html">Technical Annex</a></li>
<li><a class="" href="references.html">References</a></li>
</ul>

        <div class="book-extra">
          
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="object-based-time-series-image-analysis" class="section level1 unnumbered">
<h1>Object-based time series image analysis<a class="anchor" aria-label="anchor" href="#object-based-time-series-image-analysis"><i class="fas fa-link"></i></a>
</h1>
<p>Object-Based Image Analysis (OBIA) is an approach to remote sensing image analysis that partitions an image into closed segments which are then classified and analyzed. For high-resolution images (1 meter or smaller) the aim of OBIA is to create objects that represent meaningful features in the real world, like buildings, roads, fields, forests, and water bodies. In case of medium resolution images (such as Sentinel-2 or Landsat) the segments represent groups of the image with similar spectral responses which in general do not correspond directly to individual objects in the ground. These groups of pixels are called super-pixels. In both situations, the aim of OBIA is to obtain a spatial partition of the image which can then be assigned to a single class. When applicable, OBIA reduces processing time and produces labelled maps with greater spatial consistency.</p>
<p>The general sequence of the processes involved in OBIA in <code>sits</code> is:</p>
<ol style="list-style-type: decimal">
<li><p>Segmentation: The first step is to group together pixels that are similar based a distance metric that consider the values of all bands in all time instances. We build a multitemporal attribute space where each time/band combination is taken as an independent dimension. Thus, distance metrics for segmentation in a data cube with 10 bands and 24 time steps use a 240-dimension space.</p></li>
<li><p>Probability Estimation: After the image has been partitioned into distinct objects, the next step is to classify each segment. For satellite image time series, a subset of time series inside each segment is classified.</p></li>
<li><p>Labelling: Once the set of probabilities have been obtain for each time series inside a segment, they can be used for labelling. This is done by considering the median value of the probabilities for the time series inside the segment that have been classified. For each class, we take the median of the probability values. Then, median values for the classes are normalised, and the most likely value is assigned as the class for the segment.</p></li>
</ol>
<div id="image-segmentation-in-sits" class="section level2 unnumbered">
<h2>Image segmentation in SITS<a class="anchor" aria-label="anchor" href="#image-segmentation-in-sits"><i class="fas fa-link"></i></a>
</h2>
<p>The first step of the OBIA procedure in <code>sits</code> is to select a data cube to be segmented and function that performs the segmentation. For this purpose, <code>sits</code> provides a generic <code><a href="https://rdrr.io/pkg/sits/man/sits_segment.html">sits_segment()</a></code> function, which allows users to select different segmentation algorithms. The <code><a href="https://rdrr.io/pkg/sits/man/sits_segment.html">sits_segment()</a></code> function has the following parameters:</p>
<ul>
<li>
<code>cube</code>: a regular data cube.</li>
<li>
<code>seg_fn</code>: function to apply the segmentation</li>
<li>
<code>roi</code>: spatial region of interest in the cube</li>
<li>
<code>start_date</code>: starting date for the space-time segmentation</li>
<li>
<code>end_date</code>: final date for the space-time segmentation</li>
<li>
<code>memsize</code>: memory available for processing</li>
<li>
<code>multicores</code>: number of cores available for processing</li>
<li>
<code>output_dir</code>: output directory for the resulting cube</li>
<li>
<code>version</code>: version of the result</li>
<li>
<code>progress</code>: show progress bar?</li>
</ul>
<p>In <code>sits</code> version 1.4.2, there is only one segmentation function available (<code>sits_slic</code>) which implements the extended version of the Simple Linear Iterative Clustering (SLIC) which is described below. In future versions of <code>sits</code>, we expect to include additional functions that support spatio-temporal segmentation.</p>
</div>
<div id="simple-linear-iterative-clustering-slic-algorithm" class="section level2 unnumbered">
<h2>Simple Linear Iterative Clustering (SLIC) algorithm<a class="anchor" aria-label="anchor" href="#simple-linear-iterative-clustering-slic-algorithm"><i class="fas fa-link"></i></a>
</h2>
<p>After building the multidimensional space, we use the SLIC algorithm [Achanta2012] that clusters pixels to efficiently generate compact, nearly uniform superpixels. This algorithm has been adapted by Nowosad and Stepinski [Nowosad2022] to work with multispectral images. SLIC uses spectral similarity and proximity in the image space to segment the image into superpixels. Superpixels are clusters of pixels with similar spectral responses that are close together, which correspond to coherent object parts in the image. Here’s a high-level view of the extended SLIC algorithm:</p>
<ol style="list-style-type: decimal">
<li><p>The algorithm starts by dividing the image into a grid, where each cell of the grid will become a superpixel.</p></li>
<li><p>For each cell, the pixel in the center becomes the initial “cluster center” for that superpixel.</p></li>
<li><p>For each pixel, the algorithm calculates a distance to each of the nearby cluster centers. This distance includes both a spatial component (how far the pixel is from the center of the superpixel in terms of x and y coordinates) and a spectral component (how different the pixel’s spectral values are from the average values of the superpixel). The spectral distance is calculated using all the temporal instances of the bands.</p></li>
<li><p>Each pixel is assigned to the closest cluster. After all pixels have been assigned to clusters, the algorithm recalculates the cluster centers by averaging the spatial coordinates and spectral values of all pixels within each cluster.</p></li>
<li><p>Steps 3-4 are repeated for a set number of iterations, or until the cluster assignments stop changing.</p></li>
</ol>
<p>The outcome of the SLIC algorithm is a set of superpixels which try to capture the to boundaries of objects within the image. The SLIC implementation in <code>sits</code> 1.4.1 uses the <code>supercells</code> R package <span class="citation"><a href="references.html#ref-Nowosad2022">[88]</a></span>. The parameters for the <code><a href="https://rdrr.io/pkg/sits/man/sits_slic.html">sits_slic()</a></code> function are:</p>
<ul>
<li>
<code>dist_fn</code>: metric used to calculate the distance between values. By default, the “euclidean” metric is used. Alternatives include “jsd” (Jensen-Shannon distance), and “dtw” (dynamic time warping) or one of 46 distance and similarity measures implemented in the R package <code>philentropy</code> <span class="citation"><a href="references.html#ref-Drost2018">[89]</a></span>.</li>
<li>
<code>avg_fn</code>: function to calculate a value of each superpixel. There are two internal functions implemented in C++ - “mean” and “median”. It is also possible to provide a user-defined R function that returns one value based on an R vector.</li>
<li>
<code>step</code>: distance, measured in the number of cells, between initial superpixels’ centers.</li>
<li>
<code>compactness</code>: A value that controls superpixels’ density. Larger values cause clusters to be more compact.</li>
<li>
<code>minarea</code>: minimal size of the output superpixels (measured in number of cells).</li>
</ul>
</div>
<div id="example-of-slic-based-segmentation-and-classification" class="section level2 unnumbered">
<h2>Example of SLIC-based segmentation and classification<a class="anchor" aria-label="anchor" href="#example-of-slic-based-segmentation-and-classification"><i class="fas fa-link"></i></a>
</h2>
<p>To show an example of SLIC-based segmentation, we first build a data cube, using images available in the <code>sitsdata</code> package.</p>
<div class="sourceCode" id="cb185"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># directory where files are located</span></span>
<span><span class="va">data_dir</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/system.file.html">system.file</a></span><span class="op">(</span><span class="st">"extdata/Rondonia-20LMR"</span>, package <span class="op">=</span> <span class="st">"sitsdata"</span><span class="op">)</span></span>
<span><span class="co"># Builds a cube based on existing files</span></span>
<span><span class="va">cube_20LMR</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_cube.html">sits_cube</a></span><span class="op">(</span></span>
<span>  source <span class="op">=</span> <span class="st">"AWS"</span>,</span>
<span>  collection <span class="op">=</span> <span class="st">"SENTINEL-2-L2A"</span>,</span>
<span>  data_dir <span class="op">=</span> <span class="va">data_dir</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">cube_20LMR</span>, red <span class="op">=</span> <span class="st">"B11"</span>, green <span class="op">=</span> <span class="st">"B8A"</span>, blue <span class="op">=</span> <span class="st">"B02"</span>, date <span class="op">=</span> <span class="st">"2022-07-16"</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:unnamed-chunk-179"></span>
<img src="sitsbook_files/figure-html/unnamed-chunk-179-1.png" alt="Sentinel-2 image in an area of Rondonia in Brazil" width="100%"><p class="caption">
Figure 93: Sentinel-2 image in an area of Rondonia in Brazil
</p>
</div>
<p>The following example produces a segmented image. For the SLIC algorithm, we take the initial separation between cluster centres (<code>step</code>) to be 20 pixels, the <code>compactness</code> to be 1, and the minimum area for each superpixel (<code>min_area</code>) to be 20 pixels.</p>
<div class="sourceCode" id="cb186"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># segment a cube using SLIC</span></span>
<span><span class="co"># Files are available in a local directory</span></span>
<span><span class="va">segments_20LMR</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_segment.html">sits_segment</a></span><span class="op">(</span></span>
<span>  cube <span class="op">=</span> <span class="va">cube_20LMR</span>,</span>
<span>  output_dir <span class="op">=</span> <span class="st">"./tempdir/chp14"</span>,</span>
<span>  seg_fn <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_slic.html">sits_slic</a></span><span class="op">(</span></span>
<span>    step <span class="op">=</span> <span class="fl">20</span>,</span>
<span>    compactness <span class="op">=</span> <span class="fl">1</span>,</span>
<span>    dist_fun <span class="op">=</span> <span class="st">"euclidean"</span>,</span>
<span>    iter <span class="op">=</span> <span class="fl">20</span>,</span>
<span>    minarea <span class="op">=</span> <span class="fl">20</span></span>
<span>  <span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">segments_20LMR</span>,</span>
<span>  red <span class="op">=</span> <span class="st">"B11"</span>, green <span class="op">=</span> <span class="st">"B8A"</span>, blue <span class="op">=</span> <span class="st">"B02"</span>,</span>
<span>  date <span class="op">=</span> <span class="st">"2022-07-16"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="sitsbook_files/figure-html/unnamed-chunk-180-1.png" width="90%" style="display: block; margin: auto;"></div>
<p>It is useful to visualize the segments in a leaflet together with the RGB image using <code><a href="https://rdrr.io/pkg/sits/man/sits_view.html">sits_view()</a></code>.</p>
<div class="sourceCode" id="cb187"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_view.html">sits_view</a></span><span class="op">(</span><span class="va">segments_20LMR</span>,</span>
<span>  red <span class="op">=</span> <span class="st">"B11"</span>, green <span class="op">=</span> <span class="st">"B8A"</span>, blue <span class="op">=</span> <span class="st">"B02"</span>,</span>
<span>  dates <span class="op">=</span> <span class="st">"2022-07-16"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="images/segmentation_2.png" width="90%" style="display: block; margin: auto;"></div>
<p>After obtaining the segments, the next step is to classify them. This is done by first training a classification model. In this case study, we will use an SVM model.</p>
<div class="sourceCode" id="cb188"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">svm_model</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_train.html">sits_train</a></span><span class="op">(</span><span class="va">samples_deforestation</span>, <span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_svm.html">sits_svm</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>The segment classification procedure applies the model to a number of user-defined samples inside each segment. Each of these samples is then assigned a set of probability values, one for each class. We then obtain the median value of the probabilities for each class and normalize them. The output of the procedure is a vector data cube containing a set of classified segments. The parameters for the <code><a href="https://rdrr.io/pkg/sits/man/sits_classify.html">sits_classify()</a></code></p>
<div class="sourceCode" id="cb189"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">segments_20LMR_probs_svm</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_classify.html">sits_classify</a></span><span class="op">(</span></span>
<span>  data <span class="op">=</span> <span class="va">segments_20LMR</span>,</span>
<span>  ml_model <span class="op">=</span> <span class="va">svm_model</span>,</span>
<span>  output_dir <span class="op">=</span> <span class="st">"./tempdir/chp14"</span>,</span>
<span>  n_sam_pol <span class="op">=</span> <span class="fl">40</span>,</span>
<span>  gpu_memory <span class="op">=</span> <span class="fl">16</span>,</span>
<span>  memsize <span class="op">=</span> <span class="fl">24</span>,</span>
<span>  multicores <span class="op">=</span> <span class="fl">6</span>,</span>
<span>  version <span class="op">=</span> <span class="st">"svm-segments"</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">segments_20LMR_class_svm</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_label_classification.html">sits_label_classification</a></span><span class="op">(</span></span>
<span>  <span class="va">segments_20LMR_probs_svm</span>,</span>
<span>  output_dir <span class="op">=</span> <span class="st">"./tempdir/chp14"</span>,</span>
<span>  memsize <span class="op">=</span> <span class="fl">24</span>,</span>
<span>  multicores <span class="op">=</span> <span class="fl">6</span>,</span>
<span>  version <span class="op">=</span> <span class="st">"svm-segments"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>To view the classified segments together with the original image, use <code><a href="https://rdrr.io/r/graphics/plot.default.html">plot()</a></code> or <code><a href="https://rdrr.io/pkg/sits/man/sits_view.html">sits_view()</a></code>, as in the following example.</p>
<div class="sourceCode" id="cb190"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_view.html">sits_view</a></span><span class="op">(</span></span>
<span>  <span class="va">segments_20LMR_class_svm</span>,</span>
<span>  red <span class="op">=</span> <span class="st">"B11"</span>,</span>
<span>  green <span class="op">=</span> <span class="st">"B8A"</span>,</span>
<span>  blue <span class="op">=</span> <span class="st">"B02"</span>,</span>
<span>  dates <span class="op">=</span> <span class="st">"2022-07-16"</span>,</span>
<span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="images/segments_20LMR.png" width="90%" style="display: block; margin: auto;"></div>
<p>We conclude that OBIA analysis applied to image time series is a worthy and efficient technique for land classification, combining the desirable sharp object boundary properties required by land use and cover maps with the analytical power of image time series.</p>

</div>
</div>
  <div class="chapter-nav">
<div class="prev"><a href="ensemble-prediction-from-multiple-models.html">Ensemble prediction from multiple models</a></div>
<div class="next"><a href="technical-annex.html">Technical Annex</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#object-based-time-series-image-analysis">Object-based time series image analysis</a></li>
<li><a class="nav-link" href="#image-segmentation-in-sits">Image segmentation in SITS</a></li>
<li><a class="nav-link" href="#simple-linear-iterative-clustering-slic-algorithm">Simple Linear Iterative Clustering (SLIC) algorithm</a></li>
<li><a class="nav-link" href="#example-of-slic-based-segmentation-and-classification">Example of SLIC-based segmentation and classification</a></li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
          
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong><strong>sits</strong>: Satellite Image Time Series Analysis on Earth Observation Data Cubes</strong>" was written by Gilberto Camara, Rolf Simoes, Felipe Souza, Charlotte Pelletier, Alber Sanchez, Pedro R. Andrade, Karine Ferreira, Gilberto Queiroz. It was last built on 2023-11-06.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
